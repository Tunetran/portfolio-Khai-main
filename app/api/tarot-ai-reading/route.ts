import { NextRequest, NextResponse } from 'next/server';

interface TarotCard {
  name: string;
  suit: string;
  meaning: string;
  reversed: boolean;
  keywords: string[];
  detailedMeaning: string;
  reversedMeaning: string;
}

interface BirthInfo {
  date: string;
  time: string;
  place: string;
}

interface SpreadInfo {
  name: string;
  description: string;
  positions: string[];
}

interface AIPromptData {
  birthInfo: BirthInfo;
  cards: TarotCard[];
  spread: SpreadInfo;
  question: string;
  aspect: string;
}

export async function POST(request: NextRequest) {
  try {
    console.log('üé¥ Tarot AI API called');
    const data: AIPromptData = await request.json();
    console.log('üìù Request data received:', { 
      hasCards: !!data.cards, 
      cardsCount: data.cards?.length,
      hasQuestion: !!data.question,
      aiService: process.env.AI_SERVICE 
    });
    
    // T·∫°o prompt chi ti·∫øt cho AI
    const aiPrompt = createDetailedPrompt(data);
    console.log('üîÆ AI prompt created, length:', aiPrompt.length);
    
    // G·ªçi API AI (v√≠ d·ª•: OpenAI, Claude, ho·∫∑c AI kh√°c)
    const aiResponse = await callAIService(aiPrompt);
    console.log('‚úÖ AI response received, length:', aiResponse.length);
    
    return NextResponse.json({
      success: true,
      reading: aiResponse,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in tarot AI reading:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to generate AI reading',
      reading: 'C√≥ l·ªói x·∫£y ra khi t·∫°o ph√¢n t√≠ch AI. ƒêang chuy·ªÉn sang ch·∫ø ƒë·ªô demo...\n\n' + generateMockAIReading('')
    }, { status: 500 });
  }
}

function createDetailedPrompt(data: AIPromptData): string {
  const { birthInfo, cards, spread, question, aspect } = data;
  
  let prompt = `B·∫°n l√† m·ªôt chuy√™n gia Tarot c√≥ kinh nghi·ªám 20 nƒÉm, ƒë·∫∑c bi·ªát gi·ªèi v·ªÅ chi√™m tinh h·ªçc v√† ph√¢n t√≠ch t√¢m l√Ω s√¢u s·∫Øc.

TH√îNG TIN NG∆Ø·ªúI XEM:
- Ng√†y sinh: ${birthInfo.date}
- Gi·ªù sinh: ${birthInfo.time || 'Kh√¥ng cung c·∫•p'}
- N∆°i sinh: ${birthInfo.place || 'Kh√¥ng cung c·∫•p'}

LO·∫†I XEM TAROT: ${spread.name}
M√î T·∫¢: ${spread.description}
${question && question.trim() ? `C√ÇU H·ªéI C·ª§ TH·ªÇ: "${question}"` : 'C√ÇU H·ªéI C·ª§ TH·ªÇ: Kh√¥ng c√≥ c√¢u h·ªèi c·ª• th·ªÉ - h√£y ƒë∆∞a ra l·ªùi khuy√™n t·ªïng qu√°t'}
KH√çA C·∫†NH QUAN T√ÇM: ${aspect}

C√ÅC L√Å B√ÄI ƒê√É B·ªêC:`;

  cards.forEach((card, index) => {
    const position = spread.positions[index] || `V·ªã tr√≠ ${index + 1}`;
    prompt += `\n${index + 1}. ${position}: ${card.name} (${card.suit})${card.reversed ? ' - L·∫≠t ng∆∞·ª£c' : ''}
   - √ù nghƒ©a: ${card.meaning}
   - Keywords: ${card.keywords.join(', ')}
   - Chi ti·∫øt: ${card.reversed ? card.reversedMeaning : card.detailedMeaning}`;
  });

  prompt += `\n\nY√äU C·∫¶U PH√ÇN T√çCH:

${question && question.trim() ? 
`‚≠ê T·∫¨P TRUNG TR·ª∞C TI·∫æP V√ÄO C√ÇU H·ªéI: "${question}"
- Ph√¢n t√≠ch c√°c l√° b√†i CH√çNH X√ÅC li√™n quan ƒë·∫øn c√¢u h·ªèi n√†y
- ƒê∆∞a ra l·ªùi khuy√™n C·ª§ TH·ªÇ ƒë·ªÉ gi·∫£i quy·∫øt th·∫Øc m·∫Øc
- D·ª± ƒëo√°n k·∫øt qu·∫£ v√† h∆∞·ªõng ph√°t tri·ªÉn cho t√¨nh hu·ªëng ƒë∆∞·ª£c h·ªèi

` : ''}1. PH√ÇN T√çCH CHI√äM TINH:
- D·ª±a v√†o ng√†y sinh, ph√¢n t√≠ch cung ho√†ng ƒë·∫°o v√† ·∫£nh h∆∞·ªüng c·ªßa n√≥
- K·∫øt h·ª£p v·ªõi nƒÉng l∆∞·ª£ng c√°c l√° b√†i ƒë·ªÉ ƒë∆∞a ra insight s√¢u s·∫Øc${question && question.trim() ? ' li√™n quan ƒë·∫øn c√¢u h·ªèi' : ''}

2. PH√ÇN T√çCH C√ÅC L√Å B√ÄI:
- Gi·∫£i th√≠ch √Ω nghƒ©a t·ª´ng l√° trong ng·ªØ c·∫£nh c·ª• th·ªÉ c·ªßa ng∆∞·ªùi h·ªèi${question && question.trim() ? ' v√† c√¢u h·ªèi ƒë√£ ƒë·∫∑t' : ''}
- Ph√¢n t√≠ch m·ªëi li√™n h·ªá gi·ªØa c√°c l√° b√†i
- Ch√∫ √Ω ƒë·∫∑c bi·ªát ƒë·∫øn Major Arcana (·∫©n ch√≠nh) v√† Minor Arcana (·∫©n ph·ª•)

3. T·ªîNG H·ª¢P V√Ä L·ªúI KHUY√äN:
- ƒê∆∞a ra ph√¢n t√≠ch t·ªïng th·ªÉ d·ª±a tr√™n t·∫•t c·∫£ th√¥ng tin${question && question.trim() ? ' v·ªõi c√¢u h·ªèi l√†m tr·ªçng t√¢m' : ''}
- L·ªùi khuy√™n c·ª• th·ªÉ cho giai ƒëo·∫°n hi·ªán t·∫°i${question && question.trim() ? ' v√† c√°ch gi·∫£i quy·∫øt th·∫Øc m·∫Øc' : ''}
- D·ª± b√°o xu h∆∞·ªõng v√† c∆° h·ªôi trong t∆∞∆°ng lai g·∫ßn

4. Y√äU C·∫¶U ƒê·ªäNH D·∫†NG:
- S·ª≠ d·ª•ng markdown formatting (**, ###, etc.)
- Chia th√†nh c√°c ph·∫ßn r√µ r√†ng v·ªõi ti√™u ƒë·ªÅ
- Ng√¥n ng·ªØ ti·∫øng Vi·ªát, phong c√°ch ·∫•m √°p v√† d·ªÖ hi·ªÉu
- ƒê·ªô d√†i kho·∫£ng 800-1200 t·ª´

${question && question.trim() ? 
`üéØ L∆ØU √ù QUAN TR·ªåNG: H√£y ƒë·∫£m b·∫£o m·ªçi ph√¢n t√≠ch ƒë·ªÅu h∆∞·ªõng v·ªÅ vi·ªác tr·∫£ l·ªùi c√¢u h·ªèi "${question}" m·ªôt c√°ch chi ti·∫øt v√† th·ª±c t·∫ø.` : 
'H√£y t·∫°o m·ªôt b√†i ƒë·ªçc tarot s√¢u s·∫Øc, c√° nh√¢n h√≥a v√† c√≥ √Ω nghƒ©a th·ª±c ti·ªÖn.'}`;

  return prompt;
}

async function callAIService(prompt: string): Promise<string> {
  const aiService = process.env.AI_SERVICE || 'demo';
  
  try {
    switch (aiService) {
      case 'openai':
        return await callOpenAI(prompt);
      case 'google':
        return await callGoogleAI(prompt);
      case 'anthropic':
        return await callAnthropicAI(prompt);
      case 'ollama':
        return await callOllamaAI(prompt);
      case 'demo':
      default:
        return generateMockAIReading(prompt);
    }
  } catch (error) {
    console.error('AI service error:', error);
    return generateMockAIReading(prompt);
  }
}

async function callOpenAI(prompt: string): Promise<string> {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key not found');
  }

  console.log('ü§ñ Calling OpenAI API...');
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-3.5-turbo', // Thay ƒë·ªïi t·ª´ gpt-4 th√†nh gpt-3.5-turbo
      messages: [
        {
          role: 'system',
          content: 'B·∫°n l√† m·ªôt chuy√™n gia Tarot v√† chi√™m tinh h·ªçc c√≥ kinh nghi·ªám s√¢u s·∫Øc, c√≥ kh·∫£ nƒÉng ph√¢n t√≠ch t√¢m l√Ω v√† ƒë∆∞a ra l·ªùi khuy√™n th·ª±c t·∫ø.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 2000,
      temperature: 0.7
    })
  });

  console.log('üìû OpenAI response status:', response.status);
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error('‚ùå OpenAI API error:', response.status, errorText);
    throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
    console.error('OpenAI API response:', errorText);
    throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  return data.choices[0].message.content;
}

async function callGoogleAI(prompt: string): Promise<string> {
  if (!process.env.GOOGLE_API_KEY) {
    throw new Error('Google API key not found');
  }

  console.log('ü§ñ Calling Google Gemini API...');
  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GOOGLE_API_KEY}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: `B·∫°n l√† m·ªôt chuy√™n gia Tarot v√† chi√™m tinh h·ªçc c√≥ kinh nghi·ªám s√¢u s·∫Øc.\n\n${prompt}`
        }]
      }],
      generationConfig: {
        maxOutputTokens: 2000,
        temperature: 0.7
      }
    })
  });

  console.log('üìû Google Gemini response status:', response.status);
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error('‚ùå Google AI API error:', response.status, errorText);
    throw new Error(`Google AI API error: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  
  if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
    console.error('Invalid Google AI response structure:', data);
    throw new Error('Invalid response from Google AI');
  }
  
  return data.candidates[0].content.parts[0].text;
}

async function callAnthropicAI(prompt: string): Promise<string> {
  if (!process.env.ANTHROPIC_API_KEY) {
    throw new Error('Anthropic API key not found');
  }

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.ANTHROPIC_API_KEY}`,
      'Content-Type': 'application/json',
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: 'claude-3-sonnet-20240229',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `B·∫°n l√† m·ªôt chuy√™n gia Tarot v√† chi√™m tinh h·ªçc c√≥ kinh nghi·ªám s√¢u s·∫Øc.\n\n${prompt}`
        }
      ]
    })
  });

  if (!response.ok) {
    throw new Error(`Anthropic API error: ${response.status}`);
  }

  const data = await response.json();
  return data.content[0].text;
}

async function callOllamaAI(prompt: string): Promise<string> {
  const baseUrl = process.env.OLLAMA_BASE_URL || 'http://localhost:11434';
  
  const response = await fetch(`${baseUrl}/api/generate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'llama2', // ho·∫∑c model kh√°c b·∫°n ƒë√£ c√†i
      prompt: `B·∫°n l√† m·ªôt chuy√™n gia Tarot v√† chi√™m tinh h·ªçc c√≥ kinh nghi·ªám s√¢u s·∫Øc.\n\n${prompt}`,
      stream: false
    })
  });

  if (!response.ok) {
    throw new Error(`Ollama API error: ${response.status}`);
  }

  const data = await response.json();
  return data.response;
}

function generateMockAIReading(prompt: string): string {
  // Tr√≠ch xu·∫•t c√¢u h·ªèi t·ª´ prompt ƒë·ªÉ ph·∫£n √°nh trong ph√¢n t√≠ch
  const questionMatch = prompt.match(/C√ÇU H·ªéI C·ª§ TH·ªÇ: "([^"]+)"/);
  const userQuestion = questionMatch ? questionMatch[1] : null;
  
  // AI m√¥ ph·ªèng cho demo v·ªõi ph·∫£n √°nh c√¢u h·ªèi
  let reading = `## üåü Ph√¢n T√≠ch Tarot C√° Nh√¢n H√≥a

${userQuestion ? `### ÔøΩ Tr·∫£ L·ªùi C√¢u H·ªèi: "${userQuestion}"
C√°c l√° b√†i ƒë√£ b·ªëc mang ƒë·∫øn th√¥ng ƒëi·ªáp r√µ r√†ng v·ªÅ th·∫Øc m·∫Øc n√†y. D·ª±a v√†o nƒÉng l∆∞·ª£ng c·ªßa c√°c l√° b√†i v√† th√¥ng tin chi√™m tinh, v≈© tr·ª• ƒëang g·ª≠i ƒë·∫øn b·∫°n nh·ªØng g·ª£i √Ω qu√Ω b√°u ƒë·ªÉ gi·∫£i quy·∫øt t√¨nh hu·ªëng n√†y.

` : ''}### ÔøΩüé≠ Ph√¢n T√≠ch Chi√™m Tinh
D·ª±a v√†o th√¥ng tin ng√†y sinh c·ªßa b·∫°n, nƒÉng l∆∞·ª£ng chi√™m tinh hi·ªán t·∫°i ƒëang h·ªó tr·ª£ m·∫°nh m·∫Ω cho nh·ªØng thay ƒë·ªïi t√≠ch c·ª±c trong cu·ªôc s·ªëng${userQuestion ? ' li√™n quan ƒë·∫øn c√¢u h·ªèi b·∫°n ƒë·∫∑t ra' : ''}. S·ª± k·∫øt h·ª£p gi·ªØa v·ªã tr√≠ c√°c h√†nh tinh v√† c√°c l√° b√†i b·∫°n ƒë√£ b·ªëc cho th·∫•y m·ªôt giai ƒëo·∫°n chuy·ªÉn ƒë·ªïi quan tr·ªçng ƒëang di·ªÖn ra.

### üÉè √ù Nghƒ©a C√°c L√° B√†i

**Ph√¢n t√≠ch s√¢u v·ªÅ t·ª´ng l√° b√†i trong ng·ªØ c·∫£nh c√° nh√¢n:**
- C√°c l√° Major Arcana (·∫©n ch√≠nh) trong spread n√†y cho th·∫•y nh·ªØng b√†i h·ªçc t√¢m linh quan tr·ªçng${userQuestion ? ' li√™n quan ƒë·∫øn th·∫Øc m·∫Øc c·ªßa b·∫°n' : ''}
- Minor Arcana (·∫©n ph·ª•) ph·∫£n √°nh nh·ªØng t√¨nh hu·ªëng th·ª±c t·∫ø b·∫°n c√≥ th·ªÉ ki·ªÉm so√°t${userQuestion ? ' ƒë·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ' : ''}

${userQuestion ? `### üí° L·ªùi Khuy√™n C·ª• Th·ªÉ Cho C√¢u H·ªèi
**D·ª±a v√†o c√°c l√° b√†i ƒë√£ b·ªëc:**
- **H√†nh ƒë·ªông ngay:** Tin t∆∞·ªüng v√†o tr·ª±c gi√°c v√† th·ª±c hi·ªán nh·ªØng b∆∞·ªõc ƒëi c·∫ßn thi·∫øt
- **C·∫ßn tr√°nh:** ƒê·ª´ng ƒë·ªÉ s·ª± ho√†i nghi c·∫£n tr·ªü nh·ªØng quy·∫øt ƒë·ªãnh ƒë√∫ng ƒë·∫Øn  
- **K·∫øt qu·∫£ d·ª± ki·∫øn:** V·ªõi s·ª± ki√™n nh·∫´n v√† n·ªó l·ª±c ph√π h·ª£p, t√¨nh hu·ªëng s·∫Ω c√≥ h∆∞·ªõng ph√°t tri·ªÉn t√≠ch c·ª±c

` : ''}### üí´ T·ªïng H·ª£p & H∆∞·ªõng D·∫´n

**Th√¥ng ƒëi·ªáp ch√≠nh t·ª´ v≈© tr·ª•:**
Giai ƒëo·∫°n hi·ªán t·∫°i c·ªßa b·∫°n ƒëang mang ƒë·∫øn nh·ªØng c∆° h·ªôi tuy·ªát v·ªùi ƒë·ªÉ ph√°t tri·ªÉn b·∫£n th√¢n v√† ƒë·∫°t ƒë∆∞·ª£c nh·ªØng m·ª•c ti√™u quan tr·ªçng${userQuestion ? ', ƒë·∫∑c bi·ªát li√™n quan ƒë·∫øn th·∫Øc m·∫Øc b·∫°n ƒë√£ ƒë·∫∑t ra' : ''}. H√£y tin t∆∞·ªüng v√†o tr·ª±c gi√°c v√† kh√¥ng ng·∫°i th·ª≠ th√°ch b·∫£n th√¢n.

**L·ªùi khuy√™n c·ª• th·ªÉ:**
1. **Ng·∫Øn h·∫°n (1-3 th√°ng):** T·∫≠p trung v√†o vi·ªác ho√†n thi·ªán c√°c k·∫ø ho·∫°ch ƒë√£ b·∫Øt ƒë·∫ßu${userQuestion ? ' v√† gi·∫£i quy·∫øt th·∫Øc m·∫Øc hi·ªán t·∫°i' : ''}
2. **Trung h·∫°n (3-6 th√°ng):** Th·ªùi ƒëi·ªÉm thu·∫≠n l·ª£i cho nh·ªØng quy·∫øt ƒë·ªãnh quan tr·ªçng
3. **D√†i h·∫°n (6-12 th√°ng):** Chu·∫©n b·ªã cho m·ªôt chu k·ª≥ m·ªõi v·ªõi nhi·ªÅu th√†nh t·ª±u

### üéØ L·ªùi Nh·∫Øn ƒê·∫∑c Bi·ªát
${userQuestion ? 
`V·ªÅ c√¢u h·ªèi "${userQuestion}" - v≈© tr·ª• khuy·∫øn kh√≠ch b·∫°n h√£y m·ªü l√≤ng v√† tin t∆∞·ªüng v√†o qu√° tr√¨nh. M·ªçi th·ª© ƒëang di·ªÖn ra ƒë√∫ng nh∆∞ d·ª± ƒë·ªãnh, v√† b·∫°n c√≥ ƒë·ªß s·ª©c m·∫°nh ƒë·ªÉ v∆∞·ª£t qua m·ªçi th·ª≠ th√°ch.` :
'V≈© tr·ª• ƒëang g·ª≠i ƒë·∫øn b·∫°n m·ªôt th√¥ng ƒëi·ªáp r√µ r√†ng: ƒë√¢y l√† th·ªùi ƒëi·ªÉm ƒë·ªÉ b·∫°n b∆∞·ªõc ra kh·ªèi v√πng an to√†n v√† theo ƒëu·ªïi nh·ªØng ∆∞·ªõc m∆° l·ªõn lao. H√£y tin t∆∞·ªüng v√†o nƒÉng l·ª±c c·ªßa m√¨nh!'}

*L∆∞u √Ω: ƒê√¢y l√† ph√¢n t√≠ch m√¥ ph·ªèng. ƒê·ªÉ c√≥ k·∫øt qu·∫£ AI ch√≠nh x√°c, c·∫ßn c·∫•u h√¨nh API key cho OpenAI ho·∫∑c AI service kh√°c.*`;

  return reading;
}
